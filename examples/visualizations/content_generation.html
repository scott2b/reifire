<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Reifire Visualization</title>
    <style>
        /* Base styles */
        .canvas {
            width: 100%;
            height: 100vh;
            position: relative;
            background: #f5f5f5;
            padding: 20px;
            overflow: auto;
            margin-top: 60px;
        }
        
        .prompt-section {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e0e0e0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .prompt-label {
            font-weight: bold;
            color: #666;
        }
        
        .prompt-text {
            flex: 1;
            font-size: 16px;
            color: #333;
        }
        
        /* Component styles */
        .component {
            position: absolute;
            background: #e3f2fd;
            border: 2px solid #2196f3;
            border-radius: 8px;
            padding: 15px;
            cursor: move;
            z-index: 1;
            transition: all 0.2s;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 150px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            transform: translate(0, 0);
        }
        
        .component:hover {
            background: #bbdefb;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }

        .component .icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }

        .component .color-swatches {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .component .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .component .label {
            flex: 1;
            font-size: 14px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Component types */
        .component[data-type="object"] {
            background: #e3f2fd;
            border-color: #2196f3;
            font-weight: bold;
        }

        .component[data-type="modifier"] {
            background: #e8f5e9;
            border-color: #4caf50;
        }

        .component[data-type="type"] {
            background: #f3e5f5;
            border-color: #9c27b0;
        }

        .component[data-type="artifact"] {
            background: #fff3e0;
            border-color: #ff9800;
            font-weight: bold;
        }

        .component[data-type="attribute"] {
            background: #e8eaf6;
            border-color: #3f51b5;
        }

        .component[data-type="alternative"] {
            background: #fce4ec;
            border-color: #e91e63;
            border-style: dashed;
        }

        .component[data-type="relationship"] {
            background: #f5f5f5;
            border-color: #9e9e9e;
            border-style: solid;
        }

        /* Connection styles */
        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .connection {
            stroke: #2196f3;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            transition: all 0.2s;
        }

        .connection:hover {
            stroke-width: 3;
            filter: brightness(1.2);
        }

        .connection[data-type="modifier"] {
            stroke: #4caf50;
            marker-end: url(#arrowhead-modifier);
        }

        .connection[data-type="type"] {
            stroke: #9c27b0;
            marker-end: url(#arrowhead-type);
        }

        .connection[data-type="artifact"] {
            stroke: #ff9800;
            marker-end: url(#arrowhead-artifact);
        }

        .connection[data-type="attribute"] {
            stroke: #3f51b5;
            marker-end: url(#arrowhead-attribute);
        }

        .connection[data-type="alternative"] {
            stroke: #e91e63;
            stroke-dasharray: 4,4;
            marker-end: url(#arrowhead-alternative);
        }

        .connection[data-type="relationship"] {
            stroke: #9e9e9e;
            marker-end: url(#arrowhead-relationship);
        }

        .connection-label {
            font-size: 12px;
            background: white;
            padding: 2px 6px;
            border-radius: 3px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 2;
            pointer-events: none;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px 0;
            min-width: 150px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f5f5f5;
        }

        .context-menu-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="prompt-section">
        <span class="prompt-label">Prompt:</span>
        <span class="prompt-text">Write an Apple iPhone 15 Pro product review in professional style, expert, covering design, performance, camera, battery, verdict in 2000 words, referencing technical specs comparing performance and camera with iPhone 14 Pro.</span>
    </div>
    <div class="canvas" id="canvas">
        <svg id="connections">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#2196f3"/>
                </marker>
                <marker id="arrowhead-modifier" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#4caf50"/>
                </marker>
                <marker id="arrowhead-type" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#9c27b0"/>
                </marker>
                <marker id="arrowhead-artifact" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#ff9800"/>
                </marker>
                <marker id="arrowhead-attribute" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#3f51b5"/>
                </marker>
                <marker id="arrowhead-alternative" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#e91e63"/>
                </marker>
                <marker id="arrowhead-relationship" markerWidth="10" markerHeight="7" 
                    refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#9e9e9e"/>
                </marker>
            </defs>
        </svg>

        <div class="component" data-type="object" id="object_0" data-id="object_0"
            style="left: 50px; top: 0px; width: 200px; height: 60px;">
                        <img class="icon" src="https://static.thenounproject.com/png/4444399-84.png" alt="product review">
            <span class="label">product review</span>
        </div>
        <div class="component" data-type="modifier" id="mod_1" data-id="mod_1"
            style="left: 300px; top: 100px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/6925557-84.png" alt="product">
            <span class="label">product: Apple iPhone 15 Pro</span>
        </div>
        <div class="component" data-type="type" id="type_2" data-id="type_2"
            style="left: 300px; top: 200px; width: 200px; height: 60px;">
                        <img class="icon" src="https://static.thenounproject.com/png/5616547-84.png" alt="content">
            <span class="label">content</span>
        </div>
        <div class="component" data-type="artifact" id="artifact_3" data-id="artifact_3"
            style="left: 550px; top: 300px; width: 200px; height: 60px;">
                        <img class="icon" src="https://static.thenounproject.com/png/1030975-84.png" alt="article">
            <span class="label">artifact</span>
        </div>
        <div class="component" data-type="attribute" id="attr_4" data-id="attr_4"
            style="left: 550px; top: 400px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/7415634-84.png" alt="tone">
            <span class="label">tone: professional</span>
        </div>
        <div class="component" data-type="alternative" id="attr_5" data-id="attr_5"
            style="left: 800px; top: 500px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/7415634-84.png" alt="tone">
            <span class="label">tone: casual</span>
        </div>
        <div class="component" data-type="attribute" id="attr_6" data-id="attr_6"
            style="left: 550px; top: 600px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/2230942-84.png" alt="perspective">
            <span class="label">perspective: expert</span>
        </div>
        <div class="component" data-type="attribute" id="attr_7" data-id="attr_7"
            style="left: 550px; top: 700px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/602418-84.png" alt="structure">
            <span class="label">structure: sections</span>
        </div>
        <div class="component" data-type="attribute" id="attr_8" data-id="attr_8"
            style="left: 550px; top: 800px; width: 180px; height: 50px;">
                        <img class="icon" src="https://raw.githubusercontent.com/primer/octicons/main/icons/dot-24.svg" alt="word_count">
            <span class="label">word_count: 2000</span>
        </div>
        <div class="component" data-type="relationship" id="rel_9" data-id="rel_9"
            style="left: 550px; top: 900px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/2637669-84.png" alt="references">
            <span class="label">references: review -&gt; technical specs</span>
        </div>
        <div class="component" data-type="relationship" id="rel_10" data-id="rel_10"
            style="left: 550px; top: 1000px; width: 180px; height: 50px;">
                        <img class="icon" src="https://static.thenounproject.com/png/2462815-84.png" alt="compares">
            <span class="label">compares: iPhone 15 Pro -&gt; iPhone 14 Pro</span>
        </div>
    </div>
    <script>
        // Store component and connection data
        const componentData = [{"height": 60, "id": "object_0", "label": "product review", "properties": {"visualization": {"image": "https://static.thenounproject.com/png/4444399-84.png", "name": "product review", "source": "nounproject"}}, "type": "object", "width": 200, "x": 50, "y": 0}, {"height": 50, "id": "mod_1", "label": "product: Apple iPhone 15 Pro", "properties": {"visualization": {"image": "https://static.thenounproject.com/png/6925557-84.png", "name": "product", "source": "nounproject"}}, "type": "modifier", "width": 180, "x": 300, "y": 100}, {"height": 60, "id": "type_2", "label": "content", "properties": {"category": "textual", "visualization": {"image": "https://static.thenounproject.com/png/5616547-84.png", "name": "content", "source": "nounproject"}}, "type": "type", "width": 200, "x": 300, "y": 200}, {"height": 60, "id": "artifact_3", "label": "artifact", "properties": {"type": "article", "visualization": {"image": "https://static.thenounproject.com/png/1030975-84.png", "name": "article", "source": "nounproject"}}, "type": "artifact", "width": 200, "x": 550, "y": 300}, {"height": 50, "id": "attr_4", "label": "tone: professional", "properties": {"visualization": {"image": "https://static.thenounproject.com/png/7415634-84.png", "name": "tone", "source": "nounproject"}}, "type": "attribute", "width": 180, "x": 550, "y": 400}, {"height": 50, "id": "attr_5", "label": "tone: casual", "properties": {"visualization": {"image": "https://static.thenounproject.com/png/7415634-84.png", "name": "tone", "source": "nounproject"}}, "type": "alternative", "width": 180, "x": 800, "y": 500}, {"height": 50, "id": "attr_6", "label": "perspective: expert", "properties": {"visualization": {"image": "https://static.thenounproject.com/png/2230942-84.png", "name": "perspective", "source": "nounproject"}}, "type": "attribute", "width": 180, "x": 550, "y": 600}, {"height": 50, "id": "attr_7", "label": "structure: sections", "properties": {"properties": {"sections": ["design", "performance", "camera", "battery", "verdict"]}, "visualization": {"image": "https://static.thenounproject.com/png/602418-84.png", "name": "structure", "source": "nounproject"}}, "type": "attribute", "width": 180, "x": 550, "y": 700}, {"height": 50, "id": "attr_8", "label": "word_count: 2000", "properties": {"visualization": {"image": "https://raw.githubusercontent.com/primer/octicons/main/icons/dot-24.svg", "name": "word_count", "source": "fallback"}}, "type": "attribute", "width": 180, "x": 550, "y": 800}, {"height": 50, "id": "rel_9", "label": "references: review -\u003e technical specs", "properties": {"properties": {"validation": "required"}, "visualization": {"image": "https://static.thenounproject.com/png/2637669-84.png", "name": "references", "source": "nounproject"}}, "type": "relationship", "width": 180, "x": 550, "y": 900}, {"height": 50, "id": "rel_10", "label": "compares: iPhone 15 Pro -\u003e iPhone 14 Pro", "properties": {"properties": {"aspects": ["performance", "camera"]}, "visualization": {"image": "https://static.thenounproject.com/png/2462815-84.png", "name": "compares", "source": "nounproject"}}, "type": "relationship", "width": 180, "x": 550, "y": 1000}];
        const connectionData = [{"properties": {}, "source": "object_0", "target": "mod_1", "type": "modifier"}, {"properties": {}, "source": "object_0", "target": "type_2", "type": "type"}, {"properties": {}, "source": "object_0", "target": "artifact_3", "type": "artifact"}, {"properties": {}, "source": "artifact_3", "target": "attr_4", "type": "attribute"}, {"properties": {}, "source": "attr_4", "target": "attr_5", "type": "alternative"}, {"properties": {}, "source": "artifact_3", "target": "attr_6", "type": "attribute"}, {"properties": {"sections": ["design", "performance", "camera", "battery", "verdict"]}, "source": "artifact_3", "target": "attr_7", "type": "attribute"}, {"properties": {}, "source": "artifact_3", "target": "attr_8", "type": "attribute"}, {"properties": {}, "source": "review", "target": "rel_9", "type": "source"}, {"properties": {}, "source": "rel_9", "target": "technical specs", "type": "target"}, {"properties": {}, "source": "iPhone 15 Pro", "target": "rel_10", "type": "source"}, {"properties": {}, "source": "rel_10", "target": "iPhone 14 Pro", "type": "target"}];
        
        // Initialize SVG connections
        const svg = document.getElementById('connections');
        const canvas = document.getElementById('canvas');
        
        // Context menu handling
        let contextMenu = null;

        function showContextMenu(e, component) {
            e.preventDefault();
            
            // Remove existing context menu if any
            hideContextMenu();
            
            // Create context menu
            contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            
            // Add menu items based on component type
            const type = component.dataset.type;
            const items = [];
            
            items.push({
                label: 'Copy ID',
                action: () => {
                    navigator.clipboard.writeText(component.id);
                }
            });

            // Check if this component has an alternative
            const hasAlternative = componentData.some(comp => {
                return comp.type === 'alternative' && connectionData.some(conn => 
                    conn.type === 'alternative' && 
                    (conn.target === comp.id || conn.source === comp.id)
                );
            });

            if (hasAlternative) {
                // Find if this is the original or alternative component
                const altConnection = connectionData.find(conn => 
                    conn.type === 'alternative' && 
                    (conn.source === component.id || conn.target === component.id)
                );

                if (altConnection) {
                    // Find both components involved in the alternative connection
                    const currentComp = componentData.find(comp => comp.id === component.id);
                    const otherComponentId = altConnection.source === component.id ? 
                        altConnection.target : altConnection.source;
                    const otherComp = componentData.find(comp => comp.id === otherComponentId);

                    // The alternative is the one with type 'alternative'
                    const isAlternative = currentComp.type === 'alternative';
                    
                    items.push(
                        {type: 'separator'},
                        {
                            label: isAlternative ? 'Switch to Original' : 'Switch to Alternative',
                            action: () => {
                                if (otherComp) {
                                    // Get the current and alternative values
                                    const currentLabel = component.querySelector('.label');
                                    const currentText = currentLabel.textContent;
                                    const currentValue = currentText.includes(': ') ? 
                                        currentText.split(': ')[1] : 
                                        currentText;
                                    
                                    const otherValue = otherComp.label.includes(': ') ? 
                                        otherComp.label.split(': ')[1] : 
                                        otherComp.label;
                                    
                                    // Update the prompt text
                                    const promptText = document.querySelector('.prompt-text');
                                    if (promptText) {
                                        // Create regex patterns that handle both simple and compound terms
                                        // Add lookahead/lookbehind to preserve spaces
                                        const currentRegex = new RegExp(`(?<=^|\\s)(${currentValue})(?=\\s|$|\\b)`, 'g');
                                        promptText.textContent = promptText.textContent.replace(currentRegex, otherValue);
                                        
                                        // Clean up the text
                                        promptText.textContent = promptText.textContent
                                            .replace(/\s+/g, ' ')
                                            .trim();
                                    }
                                    
                                    // Update the component's label
                                    if (currentText.includes(': ')) {
                                        const prefix = currentText.split(': ')[0];
                                        currentLabel.textContent = `${prefix}: ${otherValue}`;
                                    } else {
                                        currentLabel.textContent = otherValue;
                                    }

                                    // Update component types
                                    const originalType = isAlternative ? otherComp.type : currentComp.type;
                                    component.dataset.type = isAlternative ? originalType : 'alternative';
                                    
                                    // Swap the connection target and source
                                    const index = connectionData.indexOf(altConnection);
                                    connectionData[index] = {
                                        ...altConnection,
                                        source: altConnection.target,
                                        target: altConnection.source
                                    };
                                    
                                    // Update the visualization
                                    updateConnections();
                                }
                            }
                        }
                    );
                }
            }

            items.push(
                {type: 'separator'},
                {
                    label: 'Rename',
                    action: () => {
                        const label = component.querySelector('.label');
                        const labelText = label.textContent;
                        // Extract the actual value, handling cases with prefixes like "region: "
                        const currentName = labelText.includes(': ') ? labelText.split(': ')[1] : labelText;
                        const newName = prompt('Enter new name:', currentName);
                        if (newName && newName !== currentName) {
                            // Update the label, preserving any prefix
                            label.textContent = labelText.includes(': ') ? 
                                labelText.split(': ')[0] + ': ' + newName : 
                                newName;
                            
                            // Update the prompt text
                            const promptText = document.querySelector('.prompt-text');
                            if (promptText) {
                                // Create a regex that matches the word boundary to avoid partial word matches
                                const regex = new RegExp(`\\b${currentName}\\b`, 'g');
                                promptText.textContent = promptText.textContent.replace(regex, newName);
                            }
                        }
                    }
                }
            );

            // Add Remove Connection option if the component has connections
            const hasConnections = connectionData.some(conn => 
                conn.source === component.id || conn.target === component.id
            );
            
            if (hasConnections) {
                items.push(
                    {type: 'separator'},
                    {
                        label: 'Remove Connections',
                        action: () => {
                            // Find all connections for this component
                            const componentConnections = connectionData.filter(conn => 
                                conn.source === component.id || conn.target === component.id
                            );
                            
                            // Remove each connection and update the prompt
                            componentConnections.forEach(conn => {
                                const index = connectionData.indexOf(conn);
                                if (index > -1) {
                                    // Get the component that is the modifier (usually the source)
                                    const modifierComponent = document.getElementById(conn.source);
                                    const targetComponent = document.getElementById(conn.target);
                                    
                                    if (modifierComponent && targetComponent) {
                                        // Get the component that is the modifier (usually the source)
                                        const isSourceModifier = modifierComponent.dataset.type === 'modifier';
                                        const modifierLabel = isSourceModifier ? 
                                            modifierComponent.querySelector('.label') : 
                                            targetComponent.querySelector('.label');
                                        
                                        if (modifierLabel) {
                                            const modifierText = modifierLabel.textContent;
                                            // Extract the value part (e.g., "baby" from "age: baby")
                                            const modifierValue = modifierText.includes(': ') ? 
                                                modifierText.split(': ')[1] : 
                                                modifierText;
                                            
                                            // Update the prompt text
                                            const promptText = document.querySelector('.prompt-text');
                                            if (promptText) {
                                                const value = modifierValue.trim();
                                                
                                                // Handle compound terms (like "scary-cute")
                                                if (value.includes('-')) {
                                                    // Split compound term and remove each part
                                                    const parts = value.split('-');
                                                    parts.forEach(part => {
                                                        const partRegex = new RegExp(`\\b${part}\\b|(?:^|\\s|-)${part}(?=\\s|$|-)`, 'g');
                                                        promptText.textContent = promptText.textContent.replace(partRegex, '');
                                                    });
                                                    // Also try to remove the full compound term
                                                    const fullRegex = new RegExp(`\\b${value}\\b|(?:^|\\s|-)${value}(?=\\s|$|-)`, 'g');
                                                    promptText.textContent = promptText.textContent.replace(fullRegex, '');
                                                } else {
                                                    // For single terms, use word boundary regex
                                                    const regex = new RegExp(`\\b${value}\\b|(?:^|\\s|-)${value}(?=\\s|$|-)`, 'g');
                                                    promptText.textContent = promptText.textContent.replace(regex, '');
                                                }
                                                
                                                // Clean up the text
                                                promptText.textContent = promptText.textContent
                                                    // Remove extra spaces
                                                    .replace(/\s+/g, ' ')
                                                    // Clean up dashes with spaces around them
                                                    .replace(/\s*-\s*/g, '-')
                                                    // Clean up multiple dashes
                                                    .replace(/-+/g, '-')
                                                    // Remove orphaned dashes
                                                    .replace(/\s-\s|\s-(?=\s|$)|-(?=\s|$)|\b-\b|-\s/g, ' ')
                                                    // Clean up commas
                                                    .replace(/,\s*,/g, ',')
                                                    .replace(/,\s*\./g, '.')
                                                    .replace(/\s*,\s*$/, '')
                                                    // Remove any remaining hyphenated word if one part is missing
                                                    .replace(/\b\w+(-\s|\s-|\s*-\s*$)|\b(-\s|\s-|\s*-\s*)\w+\b/g, '')
                                                    // Final trim and space cleanup
                                                    .trim()
                                                    .replace(/\s+/g, ' ');
                                            }
                                        }
                                    }
                                    
                                    // Remove the connection from connectionData
                                    connectionData.splice(index, 1);
                                }
                            });
                            
                            // Update the visualization
                            updateConnections();
                        }
                    }
                );
            }
            
            // Add items to menu
            items.forEach(item => {
                if (item.type === 'separator') {
                    const separator = document.createElement('div');
                    separator.className = 'context-menu-separator';
                    contextMenu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'context-menu-item';
                    menuItem.textContent = item.label;
                    menuItem.onclick = () => {
                        item.action();
                        hideContextMenu();
                    };
                    contextMenu.appendChild(menuItem);
                }
            });
            
            // Position menu
            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            
            // Add to document
            document.body.appendChild(contextMenu);
        }

        function hideContextMenu() {
            if (contextMenu) {
                contextMenu.remove();
                contextMenu = null;
            }
        }

        // Hide context menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!contextMenu?.contains(e.target)) {
                hideContextMenu();
            }
        });

        // Make components draggable
        document.querySelectorAll('.component').forEach(component => {
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;
            let xOffset = 0;
            let yOffset = 0;

            function dragStart(e) {
                if (e.type === "mousedown" && e.button === 0) { // Only left mouse button
                    const rect = component.getBoundingClientRect();
                    xOffset = rect.left - component.offsetLeft;
                    yOffset = rect.top - component.offsetTop;
                    initialX = e.clientX - xOffset;
                    initialY = e.clientY - yOffset;
                    
                    if (e.target === component || component.contains(e.target)) {
                        isDragging = true;
                    }
                }
            }

            function dragEnd(e) {
                initialX = currentX;
                initialY = currentY;
                isDragging = false;
            }

            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    xOffset = currentX;
                    yOffset = currentY;
                    
                    component.style.transform = `translate(${currentX}px, ${currentY}px)`;
                    updateConnections();
                }
            }

            // Add HTML5 drag and drop for alternatives
            component.setAttribute('draggable', 'true');

            component.addEventListener('dragstart', (e) => {
                // Only allow dragging if this is part of an alternative connection
                const hasAltConnection = connectionData.some(conn => 
                    conn.type === 'alternative' && 
                    (conn.source === component.id || conn.target === component.id)
                );
                if (hasAltConnection) {
                    e.dataTransfer.setData('text/plain', component.id);
                    component.classList.add('dragging');
                } else {
                    e.preventDefault(); // Prevent dragging if not an alternative
                }
            });

            component.addEventListener('dragend', () => {
                component.classList.remove('dragging');
            });

            component.addEventListener('dragover', (e) => {
                e.preventDefault();
                // Only show drop effect if this is a valid target for the alternative
                if (e.dataTransfer.types.includes('text/plain')) {
                    const draggedId = e.dataTransfer.getData('text/plain');
                    const isValidTarget = connectionData.some(conn => 
                        conn.type === 'alternative' && 
                        ((conn.source === component.id && conn.target === draggedId) ||
                         (conn.target === component.id && conn.source === draggedId))
                    );
                    if (isValidTarget) {
                        component.classList.add('drop-target');
                    }
                }
            });

            component.addEventListener('dragleave', () => {
                component.classList.remove('drop-target');
            });

            component.addEventListener('drop', (e) => {
                e.preventDefault();
                component.classList.remove('drop-target');
                const draggedId = e.dataTransfer.getData('text/plain');
                const draggedElement = document.getElementById(draggedId);
                
                // Check if this is a valid alternative swap
                const altConnection = connectionData.find(conn => 
                    conn.type === 'alternative' && 
                    ((conn.source === component.id && conn.target === draggedId) ||
                     (conn.target === component.id && conn.source === draggedId))
                );

                if (altConnection && draggedElement) {
                    // Get the values for both components
                    const currentLabel = component.querySelector('.label');
                    const currentText = currentLabel.textContent;
                    const currentValue = currentText.includes(': ') ? 
                        currentText.split(': ')[1] : 
                        currentText;
                    
                    const draggedLabel = draggedElement.querySelector('.label');
                    const draggedText = draggedLabel.textContent;
                    const draggedValue = draggedText.includes(': ') ? 
                        draggedText.split(': ')[1] : 
                        draggedText;
                    
                    // Update the prompt text
                    const promptText = document.querySelector('.prompt-text');
                    if (promptText) {
                        // Create regex patterns that handle both simple and compound terms
                        const currentRegex = new RegExp(`\\b${currentValue}\\b`, 'g');
                        promptText.textContent = promptText.textContent.replace(currentRegex, draggedValue);
                        promptText.textContent = promptText.textContent.replace(/\s+/g, ' ').trim();
                    }
                    
                    // Swap the labels
                    if (currentText.includes(': ')) {
                        const prefix = currentText.split(': ')[0];
                        currentLabel.textContent = `${prefix}: ${draggedValue}`;
                        draggedLabel.textContent = `${prefix}: ${currentValue}`;
                    } else {
                        currentLabel.textContent = draggedValue;
                        draggedLabel.textContent = currentValue;
                    }

                    // Get original positions before any transforms
                    const currentRect = component.getBoundingClientRect();
                    const draggedRect = draggedElement.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    // Calculate positions relative to canvas
                    const currentLeft = currentRect.left - canvasRect.left;
                    const currentTop = currentRect.top - canvasRect.top;
                    const draggedLeft = draggedRect.left - canvasRect.left;
                    const draggedTop = draggedRect.top - canvasRect.top;
                    
                    // Reset any existing transforms
                    component.style.transform = 'none';
                    draggedElement.style.transform = 'none';
                    
                    // Set absolute positions
                    component.style.left = `${draggedLeft}px`;
                    component.style.top = `${draggedTop}px`;
                    draggedElement.style.left = `${currentLeft}px`;
                    draggedElement.style.top = `${currentTop}px`;
                    
                    // Update the connection data
                    const index = connectionData.indexOf(altConnection);
                    if (index !== -1) {
                        // Swap source and target
                        connectionData[index] = {
                            ...altConnection,
                            source: altConnection.target,
                            target: altConnection.source
                        };
                    }
                    
                    // Update componentData
                    const currentCompIndex = componentData.findIndex(comp => comp.id === component.id);
                    const draggedCompIndex = componentData.findIndex(comp => comp.id === draggedId);
                    if (currentCompIndex !== -1 && draggedCompIndex !== -1) {
                        // Swap the labels
                        [componentData[currentCompIndex].label, componentData[draggedCompIndex].label] = 
                        [componentData[draggedCompIndex].label, componentData[currentCompIndex].label];
                    }
                    
                    // Update connections
                    updateConnections();
                }
            });

            // Regular mouse event listeners for dragging
            component.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            component.addEventListener('contextmenu', (e) => showContextMenu(e, component));
        });

        // Create SVG connections
        function createConnections() {
            // Clear existing connections first
            while (svg.lastChild) {
                if (svg.lastChild.tagName === 'defs') break;
                svg.removeChild(svg.lastChild);
            }

            // Create new connections
            connectionData.forEach(conn => {
                const source = document.getElementById(conn.source);
                const target = document.getElementById(conn.target);
                
                if (source && target) {
                    const sourceRect = source.getBoundingClientRect();
                    const targetRect = target.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    
                    // Calculate path relative to canvas
                    const sourceX = sourceRect.left - canvasRect.left + sourceRect.width/2;
                    const sourceY = sourceRect.top - canvasRect.top + sourceRect.height/2;
                    const targetX = targetRect.left - canvasRect.left + targetRect.width/2;
                    const targetY = targetRect.top - canvasRect.top + targetRect.height/2;
                    
                    // Create curved path
                    const dx = targetX - sourceX;
                    const dy = targetY - sourceY;
                    const curve = Math.min(Math.abs(dx), Math.abs(dy)) * 0.5;
                    
                    // Create the SVG path element
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    line.classList.add('connection');
                    line.dataset.type = conn.type;
                    
                    // Set the path data
                    const path = `M ${sourceX} ${sourceY} C ${sourceX + curve} ${sourceY}, ${targetX - curve} ${targetY}, ${targetX} ${targetY}`;
                    line.setAttribute('d', path);
                    
                    // Add to SVG
                    svg.appendChild(line);
                }
            });
        }

        // Update all connections
        function updateConnections() {
            requestAnimationFrame(createConnections);
        }

        // Initial connection creation
        createConnections();

        // Update connections on window resize
        window.addEventListener('resize', updateConnections);
    </script>
</body>
</html> 